[{"content":" # raylib overview raylib is a simple and easy-to-use library that allows us to enjoy game programming with ease. In addition to raylib itself, the author also provides other extension components. The official website of raylib is https://www.raylib.com/, where you can find more detailed information.\n# Purpose of This Blog The author came across this lib by chance. After some hands-on experience, an idea emerged: could the modules provided by the raylib author be integrated with raylib using CMake? After a period of research, a basic integration was successfully achieved. This blog will document the integration process and the issues encountered along the way.\n# begin # environment variables 1.cmake https://cmake.org/ Just download the latest version\n2.mingw https://github.com/niXman/mingw-builds-binaries/releases Choose the appropriate version based on your operating system. Of course, you can also opt for other build tools.For Windows users, it is recommended to select the posix-seh-ucrt-rt version. Please research the differences between other versions as needed.If you download the build tools from other sources, make sure to check whether the GCC version is outdated. The author previously encountered errors caused by an outdated GCC version, which took quite some time to troubleshoot. The command to check the GCC version on Windows is: gcc -v\n3.Configure environment variables Add the bin paths of CMake and MinGW to your system\u0026rsquo;s environment variables. Please refer to online guides for instructions on how to configure environment variables.\n4.Additional Operations It is recommended for Windows users to copy mingw32-make.exe and rename it to make.exe. If Visual Studio is not installed on your computer, you may encounter errors due to the absence of compilers like MSVC.\n# File structure Create a project folder, and it is recommended to organize it with the following structure:\nassets // Resource files build // Build directory include // Header files lib // Third-party libraries src // Source files CMakeLists.txt // CMake configuration file # Writing the CMakeLists.txt File # Top-Level CMakeLists.txt This is the main CMakeLists.txt file located in the root directory of your project:\n1 2 3 4 5 6 7 8 9 10 11 12 13 # Specify the minimum required version of CMake cmake_minimum_required(VERSION 3.20) # Set the project name project(sol) # Specify the C++ standard set(CMAKE_CXX_STANDARD 20) # Generate compile_commands.json set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # Add the src directory as a subdirectory add_subdirectory(\u0026#34;src\u0026#34;) The CMake version specified here should not be higher than the version installed on your system.\n# CMakeLists.txt Inside the src Directory First, create a test .cpp file inside the src folder. Then, add the following configuration to src/CMakeLists.txt:\n1 2 3 4 5 6 7 8 9 10 11 12 # Include all source files in the src directory aux_source_directory(${PROJECT_SOURCE_DIR}/src SRC) # Set the output path for the executable set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) # Specify the path to header files include_directories(${PROJECT_SOURCE_DIR}/include) # Specify the path to third-party libraries link_directories(${PROJECT_SOURCE_DIR}/lib) ${PROJECT_SOURCE_DIR} It refers to the root directory of the project. The above configuration defines the set of files to be compiled, the paths to header files and libraries, and sets the output directory for the executable to the bin folder in the project’s root directory (this folder will be automatically created if it doesn’t exist during the build process).\n# raylib Related configurations Based on the example provided in the official project\u0026rsquo;s CMakeLists.txt, I have made the following integrations and modifications.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 set(RAYLIB_VERSION 5.5) find_package(raylib ${RAYLIB_VERSION} QUIET) # QUIET or REQUIRED if (NOT raylib_FOUND) # If there\u0026#39;s none, fetch and build raylib include(FetchContent) FetchContent_Declare( raylib DOWNLOAD_EXTRACT_TIMESTAMP OFF URL https://github.com/raysan5/raylib/archive/refs/tags/${RAYLIB_VERSION}.tar.gz ) FetchContent_GetProperties(raylib) if (NOT raylib_POPULATED) # Have we downloaded raylib yet? set(FETCHCONTENT_QUIET NO) FetchContent_MakeAvailable(raylib) set(BUILD_EXAMPLES OFF CACHE BOOL \u0026#34;\u0026#34; FORCE) # don\u0026#39;t build the supplied examples endif() endif() set(RAYGUI_VERSION 4.0) find_package(raygui ${RAYGUI_VERSION} QUIET) # QUIET or REQUIRED if (NOT raygui_FOUND) # If there\u0026#39;s none, fetch and build raylib include(FetchContent) FetchContent_Declare( raygui DOWNLOAD_EXTRACT_TIMESTAMP OFF URL https://github.com/raysan5/raygui/archive/refs/heads/master.zip ) FetchContent_GetProperties(raygui) if (NOT raygui_POPULATED) # Have we downloaded raylib yet? set(FETCHCONTENT_QUIET NO) FetchContent_MakeAvailable(raygui) set(BUILD_RAYGUI_EXAMPLES OFF CACHE BOOL \u0026#34;\u0026#34; FORCE) # don\u0026#39;t build the supplied examples add_subdirectory(${raygui_SOURCE_DIR}/projects/CMake ${raygui_BINARY_DIR}) endif() endif() set(RRES_VERSION 1.2.0) find_package(rres ${RRES_VERSION} QUIET) # QUIET or REQUIRED if (NOT rres_FOUND) # If there\u0026#39;s none, fetch and build raylib include(FetchContent) FetchContent_Declare( rres DOWNLOAD_EXTRACT_TIMESTAMP OFF URL https://github.com/raysan5/rres/archive/refs/heads/master.zip ) FetchContent_GetProperties(rres) if (NOT rres_POPULATED) # Have we downloaded raylib yet? set(FETCHCONTENT_QUIET NO) FetchContent_MakeAvailable(rres) set(BUILD_RRES_EXAMPLES OFF CACHE BOOL \u0026#34;\u0026#34; FORCE) # don\u0026#39;t build the supplied examples add_subdirectory(${rres_SOURCE_DIR}/projects/CMake ${rres_BINARY_DIR}) endif() endif() option(SUPPORT_FILEFORMAT_WAV \u0026#34;WAV Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_OGG \u0026#34;OGG Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_MP3 \u0026#34;MP3 Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_QOA \u0026#34;QOA Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_FLAC \u0026#34;FLAC Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_XM \u0026#34;XM Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_MOD \u0026#34;MOD Support\u0026#34; TRUE) file(COPY ${PROJECT_SOURCE_DIR}/include/rres/rres-raylib.h DESTINATION ${rres_SOURCE_DIR}/src) # Our Project add_executable(${PROJECT_NAME} ${SRC}) #set(raylib_VERBOSE 1) target_link_libraries(${PROJECT_NAME} raylib raygui rres) # Web Configurations if (${PLATFORM} STREQUAL \u0026#34;Web\u0026#34;) set_target_properties(${PROJECT_NAME} PROPERTIES SUFFIX \u0026#34;.html\u0026#34;) # Tell Emscripten to build an example.html file. set(CMAKE_EXE_LINKER_FLAGS \u0026#34;${CMAKE_EXE_LINKER_FLAGS} -s USE_GLFW=3 -s ASSERTIONS=1 -s WASM=1 -s ASYNCIFY -s GL_ENABLE_GET_PROC_ADDRESS=1\u0026#34;) endif() # Checks if OSX and links appropriate frameworks (Only required on MacOS) if (APPLE) target_link_libraries(${PROJECT_NAME} \u0026#34;-framework IOKit\u0026#34;) target_link_libraries(${PROJECT_NAME} \u0026#34;-framework Cocoa\u0026#34;) target_link_libraries(${PROJECT_NAME} \u0026#34;-framework OpenGL\u0026#34;) endif() The key part lies in the use of find_package. If the corresponding package is not found, CMake will automatically use the package configured in the code.Since raudio has already been integrated into raylib by the author, you only need to download raylib, raygui, and rres.\n# Write test code If you are using C++ code, you will need to make certain modifications to the rres-raylib.h header file; otherwise, compilation errors may occur. The changes are as follows\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //line 567 crypto_argon2_inputs inputs = { .pass = (const uint8_t *)rresGetCipherPassword(), // User password .salt = salt, // Salt for the password .pass_size = (uint32_t)strlen(rresGetCipherPassword()), // Password length .salt_size = 16| }; //line 641 crypto_argon2_inputs inputs = { .pass = (const uint8_t *)rresGetCipherPassword(), // User password .salt = salt, // Salt for the password .pass_size = (uint32_t)strlen(rresGetCipherPassword()), // Password length .salt_size = 16| }; //line 669 int decryptResult = crypto_aead_unlock(decryptedData, mac, key, nonce, NULL, 0, (const u8 *)chunk-\u0026gt;data.raw, (chunk-\u0026gt;info.packedSize - 16 - 24 - 16)); Since the source code is written in C, modifying the rres-raylib.h header file will make it compatible with C++.\nTest Reference\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 #include \u0026lt;iostream\u0026gt; #include \u0026#34;raylib.h\u0026#34; #define RAYGUI_IMPLEMENTATION #define RAYGUI_SUPPORT_ICONS #include \u0026#34;raygui.h\u0026#34; #define RRES_IMPLEMENTATION #include \u0026#34;rres.h\u0026#34; #define RRES_RAYLIB_IMPLEMENTATION #define RRES_SUPPORT_COMPRESSION_LZ4 #define RRES_SUPPORT_ENCRYPTION_AES #define RRES_SUPPORT_ENCRYPTION_XCHACHA20 #include \u0026#34;rres-raylib.h\u0026#34; // Required to map rres data chunks into raylib structs #include \u0026lt;conio.h\u0026gt; // Windows only, no stardard library #define KEY_ESCAPE 27 static unsigned char *LoadDataBuffer(rresResourceChunkData data, unsigned int rawSize); static void UnloadDataBuffer(unsigned char *buffer); // Unload data buffer int main(void) { FILE *rresFile = fopen(\u0026#34;Gloomwood.rres\u0026#34;, \u0026#34;wb\u0026#34;); // Define rres file header // NOTE: We are loading 4 files that generate 5 resource chunks to save in rres rresFileHeader header = { .id{\u0026#39;r\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;s\u0026#39;}, // File identifier: rres .version = 100, // File version: 100 for version 1.0 .chunkCount = 1, // Number of resource chunks in the file (MAX: 65535) .cdOffset = 0, // Central Directory offset in file (0 if not available) .reserved = 0 // \u0026lt;reserved\u0026gt; }; // Write rres file header fwrite(\u0026amp;header, sizeof(rresFileHeader), 1, rresFile); rresResourceChunkInfo chunkInfo = { 0 }; // Chunk info rresResourceChunkData chunkData = { 0 }; // Chunk data unsigned char *buffer = NULL; Wave musicAssets = LoadWave(\u0026#34;../asset/Gloomwood.wav\u0026#34;); unsigned int rawSize = musicAssets.frameCount*musicAssets.channels*(musicAssets.sampleSize/8); // Define chunk info: WAVE chunkInfo.type[0] = \u0026#39;W\u0026#39;; // Resource chunk type (FourCC) chunkInfo.type[1] = \u0026#39;A\u0026#39;; // Resource chunk type (FourCC) chunkInfo.type[2] = \u0026#39;V\u0026#39;; // Resource chunk type (FourCC) chunkInfo.type[3] = \u0026#39;E\u0026#39;; // Resource chunk type (FourCC) //Resource chunk identifier (generated from filename CRC32 hash) char bufferPath[2048] = \u0026#34;../asset/Gloomwood.wav\u0026#34;; unsigned char* path = reinterpret_cast\u0026lt;unsigned char *\u0026gt;(bufferPath); chunkInfo.id = rresComputeCRC32(path, strlen(\u0026#34;../asset/Gloomwood.wav\u0026#34;)); chunkInfo.compType = RRES_COMP_NONE, // Data compression algorithm chunkInfo.cipherType = RRES_CIPHER_NONE, // Data encription algorithm chunkInfo.flags = 0, // Data flags (if required) chunkInfo.baseSize = 5*sizeof(unsigned int) + rawSize; // Data base size (uncompressed/unencrypted) chunkInfo.packedSize = chunkInfo.baseSize; // Data chunk size (compressed/encrypted + custom data appended) chunkInfo.nextOffset = 0, // Next resource chunk global offset (if resource has multiple chunks) chunkInfo.reserved = 0, // \u0026lt;reserved\u0026gt; // Define chunk data: WAVE chunkData.propCount = 4; chunkData.props = (unsigned int *)RRES_CALLOC(chunkData.propCount, sizeof(unsigned int)); chunkData.props[0] = musicAssets.frameCount; // props[0]:frameCount chunkData.props[1] = musicAssets.sampleRate; // props[1]:sampleRate chunkData.props[2] = musicAssets.sampleSize; // props[2]:sampleSize chunkData.props[3] = musicAssets.channels; // props[3]:channels chunkData.raw = musicAssets.data; // Get a continuous data buffer from chunkData buffer = LoadDataBuffer(chunkData, rawSize); // Compute data chunk CRC32 (propCount + props[] + data) chunkInfo.crc32 = rresComputeCRC32(buffer, chunkInfo.packedSize); // Write resource chunk into rres file fwrite(\u0026amp;chunkInfo, sizeof(rresResourceChunkInfo), 1, rresFile); fwrite(buffer, 1, chunkInfo.packedSize, rresFile); // Free required memory memset(\u0026amp;chunkInfo, 0, sizeof(rresResourceChunkInfo)); RRES_FREE(chunkData.props); UnloadDataBuffer(buffer); UnloadWave(musicAssets); fclose(rresFile); Sound sound = { 0 }; // Store RRES_DATA_WAVE loaded data -\u0026gt; LoadSoundFromWave() // Load content from rres file rresResourceChunk chunk = { 0 }; // Single resource chunk rresResourceMulti multi = { 0 }; // Multiple resource chunks static unsigned char key = 0; InitAudioDevice(); Music music = LoadMusicStream(\u0026#34;../asset/kano.mp3\u0026#34;); PlayMusicStream(music); printf(\u0026#34;\\nPress ESC to stop...\\n\u0026#34;); while (key != KEY_ESCAPE) { key = 0; if (_kbhit()) key = _getch(); UpdateMusicStream(music); } UnloadMusicStream(music); // Unload music stream data InitWindow(400, 200, \u0026#34;Sol plan test\u0026#34;); SetTargetFPS(60); bool showMessageBox = false; while (!WindowShouldClose()) { // Draw //---------------------------------------------------------------------------------- BeginDrawing(); ClearBackground(GetColor(GuiGetStyle(DEFAULT, BACKGROUND_COLOR))); if (GuiButton((Rectangle){ 24, 24, 120, 30 }, \u0026#34;#191#Show Message\u0026#34;)) showMessageBox = true; if (showMessageBox) { int result = GuiMessageBox((Rectangle){ 85, 70, 250, 100 }, \u0026#34;#191#Message Box\u0026#34;, \u0026#34;Hi! This is SolPlan!\u0026#34;, \u0026#34;just test\u0026#34;); if (result \u0026gt;= 0) showMessageBox = false; } EndDrawing(); } CloseAudioDevice(); CloseWindow(); return 0; } // Load a continuous data buffer from rresResourceChunkData struct static unsigned char *LoadDataBuffer(rresResourceChunkData data, unsigned int rawSize) { unsigned char *buffer = (unsigned char *)RRES_CALLOC((data.propCount + 1)*sizeof(unsigned int) + rawSize, 1); memcpy(buffer, \u0026amp;data.propCount, sizeof(unsigned int)); for (int i = 0; i \u0026lt; data.propCount; i++) memcpy(buffer + (i + 1)*sizeof(unsigned int), \u0026amp;data.props[i], sizeof(unsigned int)); memcpy(buffer + (data.propCount + 1)*sizeof(unsigned int), data.raw, rawSize); return buffer; } // Unload data buffer static void UnloadDataBuffer(unsigned char *buffer) { RRES_FREE(buffer); } # build Finally, create a build folder in the project’s root directory. Open the command line in the build folder and enter the following commands in sequence:\n1 2 cmake ../ -G\u0026#34;Unix Makefiles\u0026#34; make -G “Unix Makefiles” If you are using Windows and need to makefiles, you need to add this statement. The download may fail during runtime due to network effects, just try a few more times. If everything is fine, you should see a bin folder in the root directory with an executable file in it, and if the executable file runs normally, you are done.\n# End If you don\u0026rsquo;t want to go through the trouble, you can download my project directly from github. https://github.com/IyuMashiro/raylib_raygui_rres_template\n","date":"2025-02-04T00:00:00Z","image":"https://iyumashiro.github.io/img/kano.png","permalink":"https://iyumashiro.github.io/en/p/cmake/","title":"useCmakeBuildRaylib"}]