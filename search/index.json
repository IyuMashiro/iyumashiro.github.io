[{"content":" # raylib 概述 raylib 是一个简单易用的库，是我们可以较为简单的享受游戏编程。除此之为 raylib 的作者还提供其他的扩展组件。 https://www.raylib.com/ 是 raylib 的官方网站，可以通过此网站获取更加详细的信息\n# 本博客的目的 作者也是在机缘巧合的情况下了解到该库，经过一番体验下来，便突发奇想能否通过cmake 将raylib 作者提供的模块与 raylib 整合到一起，经过一段时间的研究终于完成简易的整合，该博客将记录整合的过程和遇到的问题\n# 开始 # 环境准备 1.cmake https://cmake.org/ 下载最新版即可\n2.mingw https://github.com/niXman/mingw-builds-binaries/releases 根据自己的操作系统选择对应的版本，当然你也可以选择其他的构建工具 win用户可选 posix-seh-ucrt-rt 的版本，其他版本的区别请自行查询，如果是从其他渠道下载的构建工具请一定要检查 gcc 的版本是否过低，之前作者就因 gcc 过低导致的报错，排了好一会的错误 windows 下的指令为 gcc -v\n3.配置环境变量 将 cmake 和 mingw 的 bin 路径配置到系统的环境变量中，配置环境的变量的方法请自行查找\n4.额外操作 此处建议 windows 用户将 mingw32-make 复制并重命名为 make，如果你的电脑上没有安装过 visual studio 可能会不存在 msvc 等其他编译器导致报错。\n# 文件结构 创建一个项目文件夹，在此文件夹中建议为如下的结构\nasset 资源文件夹 build 构建文件夹 includ 存放头文件 lib 存放第三方库 src 存放源文件 CMakeLists.txt cmake 文件 # 编写 CMakeLists.txt # 外层 CMakeLists.txt 即文件目录下最外层的 CMakeLists.txt 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 #指定 cmake 最低版本 cmake_minimum_required(VERSION 3.20) #指定项目名称 project(sol) #指定C++标准 set(CMAKE_CXX_STANDARD 20) # Generate compile_commands.json set(CMAKE_EXPORT_COMPILE_COMMANDS ON) #添加子目录 add_subdirectory(\u0026#34;src\u0026#34;) 其中指定 cmake 最低版本中填写的版本不得高于当前使用的版本\n# src 下的 CMakeLists.txt 首先先创建一个测试 cpp 文件 并在 CMakeLists.txt 中添加如下配置\n1 2 3 4 5 6 7 8 9 10 11 12 #设定参与编译的文件集合 aux_source_directory(${PROJECT_SOURCE_DIR}/src SRC) #设定可执行文件的输出路径 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) #设定头文件路径 include_directories(${PROJECT_SOURCE_DIR}/include) #设定库路径 link_directories(${PROJECT_SOURCE_DIR}/lib) ${PROJECT_SOURCE_DIR} 为项目的根目录 上方的配置定义了参与编译的文件集合、头文件路径和库路径，并设定的可执行文件输出指根目录下的bin文件夹中(没有构建时会自动创建)\n# raylib 相关配置 根据官方项目中 CMakeLists.txt 的示例我做了如下整合与修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 set(RAYLIB_VERSION 5.5) find_package(raylib ${RAYLIB_VERSION} QUIET) # QUIET or REQUIRED if (NOT raylib_FOUND) # If there\u0026#39;s none, fetch and build raylib include(FetchContent) FetchContent_Declare( raylib DOWNLOAD_EXTRACT_TIMESTAMP OFF URL https://github.com/raysan5/raylib/archive/refs/tags/${RAYLIB_VERSION}.tar.gz ) FetchContent_GetProperties(raylib) if (NOT raylib_POPULATED) # Have we downloaded raylib yet? set(FETCHCONTENT_QUIET NO) FetchContent_MakeAvailable(raylib) set(BUILD_EXAMPLES OFF CACHE BOOL \u0026#34;\u0026#34; FORCE) # don\u0026#39;t build the supplied examples endif() endif() set(RAYGUI_VERSION 4.0) find_package(raygui ${RAYGUI_VERSION} QUIET) # QUIET or REQUIRED if (NOT raygui_FOUND) # If there\u0026#39;s none, fetch and build raylib include(FetchContent) FetchContent_Declare( raygui DOWNLOAD_EXTRACT_TIMESTAMP OFF URL https://github.com/raysan5/raygui/archive/refs/heads/master.zip ) FetchContent_GetProperties(raygui) if (NOT raygui_POPULATED) # Have we downloaded raylib yet? set(FETCHCONTENT_QUIET NO) FetchContent_MakeAvailable(raygui) set(BUILD_RAYGUI_EXAMPLES OFF CACHE BOOL \u0026#34;\u0026#34; FORCE) # don\u0026#39;t build the supplied examples add_subdirectory(${raygui_SOURCE_DIR}/projects/CMake ${raygui_BINARY_DIR}) endif() endif() set(RRES_VERSION 1.2.0) find_package(rres ${RRES_VERSION} QUIET) # QUIET or REQUIRED if (NOT rres_FOUND) # If there\u0026#39;s none, fetch and build raylib include(FetchContent) FetchContent_Declare( rres DOWNLOAD_EXTRACT_TIMESTAMP OFF URL https://github.com/raysan5/rres/archive/refs/heads/master.zip ) FetchContent_GetProperties(rres) if (NOT rres_POPULATED) # Have we downloaded raylib yet? set(FETCHCONTENT_QUIET NO) FetchContent_MakeAvailable(rres) set(BUILD_RRES_EXAMPLES OFF CACHE BOOL \u0026#34;\u0026#34; FORCE) # don\u0026#39;t build the supplied examples add_subdirectory(${rres_SOURCE_DIR}/projects/CMake ${rres_BINARY_DIR}) endif() endif() option(SUPPORT_FILEFORMAT_WAV \u0026#34;WAV Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_OGG \u0026#34;OGG Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_MP3 \u0026#34;MP3 Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_QOA \u0026#34;QOA Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_FLAC \u0026#34;FLAC Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_XM \u0026#34;XM Support\u0026#34; TRUE) option(SUPPORT_FILEFORMAT_MOD \u0026#34;MOD Support\u0026#34; TRUE) file(COPY ${PROJECT_SOURCE_DIR}/include/rres/rres-raylib.h DESTINATION ${rres_SOURCE_DIR}/src) # Our Project add_executable(${PROJECT_NAME} ${SRC}) #set(raylib_VERBOSE 1) target_link_libraries(${PROJECT_NAME} raylib raygui rres) # Web Configurations if (${PLATFORM} STREQUAL \u0026#34;Web\u0026#34;) set_target_properties(${PROJECT_NAME} PROPERTIES SUFFIX \u0026#34;.html\u0026#34;) # Tell Emscripten to build an example.html file. set(CMAKE_EXE_LINKER_FLAGS \u0026#34;${CMAKE_EXE_LINKER_FLAGS} -s USE_GLFW=3 -s ASSERTIONS=1 -s WASM=1 -s ASYNCIFY -s GL_ENABLE_GET_PROC_ADDRESS=1\u0026#34;) endif() # Checks if OSX and links appropriate frameworks (Only required on MacOS) if (APPLE) target_link_libraries(${PROJECT_NAME} \u0026#34;-framework IOKit\u0026#34;) target_link_libraries(${PROJECT_NAME} \u0026#34;-framework Cocoa\u0026#34;) target_link_libraries(${PROJECT_NAME} \u0026#34;-framework OpenGL\u0026#34;) endif() 关键在于 find_package 的部分。如果没有找到对应的包，将会自动代码中配置的包，其中raudio 已经被作者整合到 raylib 中 ，故只需要下载 raylib、raygui和rres即可。\n# 编写测试代码 注意如果使用的 cpp 代码需要对 rres-raylib.h 头文件做出一定的修改否则编译报错 修改如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //line 567 crypto_argon2_inputs inputs = { .pass = (const uint8_t *)rresGetCipherPassword(), // User password .salt = salt, // Salt for the password .pass_size = (uint32_t)strlen(rresGetCipherPassword()), // Password length .salt_size = 16| }; //line 641 crypto_argon2_inputs inputs = { .pass = (const uint8_t *)rresGetCipherPassword(), // User password .salt = salt, // Salt for the password .pass_size = (uint32_t)strlen(rresGetCipherPassword()), // Password length .salt_size = 16| }; //line 669 int decryptResult = crypto_aead_unlock(decryptedData, mac, key, nonce, NULL, 0, (const u8 *)chunk-\u0026gt;data.raw, (chunk-\u0026gt;info.packedSize - 16 - 24 - 16)); 可能是源代码是用c编写的作者，修改后即可兼容 cpp\n测试参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 #include \u0026lt;iostream\u0026gt; #include \u0026#34;raylib.h\u0026#34; #define RAYGUI_IMPLEMENTATION #define RAYGUI_SUPPORT_ICONS #include \u0026#34;raygui.h\u0026#34; #define RRES_IMPLEMENTATION #include \u0026#34;rres.h\u0026#34; #define RRES_RAYLIB_IMPLEMENTATION #define RRES_SUPPORT_COMPRESSION_LZ4 #define RRES_SUPPORT_ENCRYPTION_AES #define RRES_SUPPORT_ENCRYPTION_XCHACHA20 #include \u0026#34;rres-raylib.h\u0026#34; // Required to map rres data chunks into raylib structs #include \u0026lt;conio.h\u0026gt; // Windows only, no stardard library #define KEY_ESCAPE 27 static unsigned char *LoadDataBuffer(rresResourceChunkData data, unsigned int rawSize); static void UnloadDataBuffer(unsigned char *buffer); // Unload data buffer int main(void) { FILE *rresFile = fopen(\u0026#34;Gloomwood.rres\u0026#34;, \u0026#34;wb\u0026#34;); // Define rres file header // NOTE: We are loading 4 files that generate 5 resource chunks to save in rres rresFileHeader header = { .id{\u0026#39;r\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;s\u0026#39;}, // File identifier: rres .version = 100, // File version: 100 for version 1.0 .chunkCount = 1, // Number of resource chunks in the file (MAX: 65535) .cdOffset = 0, // Central Directory offset in file (0 if not available) .reserved = 0 // \u0026lt;reserved\u0026gt; }; // Write rres file header fwrite(\u0026amp;header, sizeof(rresFileHeader), 1, rresFile); rresResourceChunkInfo chunkInfo = { 0 }; // Chunk info rresResourceChunkData chunkData = { 0 }; // Chunk data unsigned char *buffer = NULL; Wave musicAssets = LoadWave(\u0026#34;../asset/Gloomwood.wav\u0026#34;); unsigned int rawSize = musicAssets.frameCount*musicAssets.channels*(musicAssets.sampleSize/8); // Define chunk info: WAVE chunkInfo.type[0] = \u0026#39;W\u0026#39;; // Resource chunk type (FourCC) chunkInfo.type[1] = \u0026#39;A\u0026#39;; // Resource chunk type (FourCC) chunkInfo.type[2] = \u0026#39;V\u0026#39;; // Resource chunk type (FourCC) chunkInfo.type[3] = \u0026#39;E\u0026#39;; // Resource chunk type (FourCC) //Resource chunk identifier (generated from filename CRC32 hash) char bufferPath[2048] = \u0026#34;../asset/Gloomwood.wav\u0026#34;; unsigned char* path = reinterpret_cast\u0026lt;unsigned char *\u0026gt;(bufferPath); chunkInfo.id = rresComputeCRC32(path, strlen(\u0026#34;../asset/Gloomwood.wav\u0026#34;)); chunkInfo.compType = RRES_COMP_NONE, // Data compression algorithm chunkInfo.cipherType = RRES_CIPHER_NONE, // Data encription algorithm chunkInfo.flags = 0, // Data flags (if required) chunkInfo.baseSize = 5*sizeof(unsigned int) + rawSize; // Data base size (uncompressed/unencrypted) chunkInfo.packedSize = chunkInfo.baseSize; // Data chunk size (compressed/encrypted + custom data appended) chunkInfo.nextOffset = 0, // Next resource chunk global offset (if resource has multiple chunks) chunkInfo.reserved = 0, // \u0026lt;reserved\u0026gt; // Define chunk data: WAVE chunkData.propCount = 4; chunkData.props = (unsigned int *)RRES_CALLOC(chunkData.propCount, sizeof(unsigned int)); chunkData.props[0] = musicAssets.frameCount; // props[0]:frameCount chunkData.props[1] = musicAssets.sampleRate; // props[1]:sampleRate chunkData.props[2] = musicAssets.sampleSize; // props[2]:sampleSize chunkData.props[3] = musicAssets.channels; // props[3]:channels chunkData.raw = musicAssets.data; // Get a continuous data buffer from chunkData buffer = LoadDataBuffer(chunkData, rawSize); // Compute data chunk CRC32 (propCount + props[] + data) chunkInfo.crc32 = rresComputeCRC32(buffer, chunkInfo.packedSize); // Write resource chunk into rres file fwrite(\u0026amp;chunkInfo, sizeof(rresResourceChunkInfo), 1, rresFile); fwrite(buffer, 1, chunkInfo.packedSize, rresFile); // Free required memory memset(\u0026amp;chunkInfo, 0, sizeof(rresResourceChunkInfo)); RRES_FREE(chunkData.props); UnloadDataBuffer(buffer); UnloadWave(musicAssets); fclose(rresFile); Sound sound = { 0 }; // Store RRES_DATA_WAVE loaded data -\u0026gt; LoadSoundFromWave() // Load content from rres file rresResourceChunk chunk = { 0 }; // Single resource chunk rresResourceMulti multi = { 0 }; // Multiple resource chunks static unsigned char key = 0; InitAudioDevice(); Music music = LoadMusicStream(\u0026#34;../asset/kano.mp3\u0026#34;); PlayMusicStream(music); printf(\u0026#34;\\nPress ESC to stop...\\n\u0026#34;); while (key != KEY_ESCAPE) { key = 0; if (_kbhit()) key = _getch(); UpdateMusicStream(music); } UnloadMusicStream(music); // Unload music stream data InitWindow(400, 200, \u0026#34;Sol plan test\u0026#34;); SetTargetFPS(60); bool showMessageBox = false; while (!WindowShouldClose()) { // Draw //---------------------------------------------------------------------------------- BeginDrawing(); ClearBackground(GetColor(GuiGetStyle(DEFAULT, BACKGROUND_COLOR))); if (GuiButton((Rectangle){ 24, 24, 120, 30 }, \u0026#34;#191#Show Message\u0026#34;)) showMessageBox = true; if (showMessageBox) { int result = GuiMessageBox((Rectangle){ 85, 70, 250, 100 }, \u0026#34;#191#Message Box\u0026#34;, \u0026#34;Hi! This is SolPlan!\u0026#34;, \u0026#34;just test\u0026#34;); if (result \u0026gt;= 0) showMessageBox = false; } EndDrawing(); } CloseAudioDevice(); CloseWindow(); return 0; } // Load a continuous data buffer from rresResourceChunkData struct static unsigned char *LoadDataBuffer(rresResourceChunkData data, unsigned int rawSize) { unsigned char *buffer = (unsigned char *)RRES_CALLOC((data.propCount + 1)*sizeof(unsigned int) + rawSize, 1); memcpy(buffer, \u0026amp;data.propCount, sizeof(unsigned int)); for (int i = 0; i \u0026lt; data.propCount; i++) memcpy(buffer + (i + 1)*sizeof(unsigned int), \u0026amp;data.props[i], sizeof(unsigned int)); memcpy(buffer + (data.propCount + 1)*sizeof(unsigned int), data.raw, rawSize); return buffer; } // Unload data buffer static void UnloadDataBuffer(unsigned char *buffer) { RRES_FREE(buffer); } # build 最后在根目录下创建 build 文件夹，在 build 文件夹下启动命令行 ，按顺序输入如下指令\n1 2 cmake ../ -G\u0026#34;Unix Makefiles\u0026#34; make -G\u0026quot;Unix Makefiles\u0026quot; 如果是Windows 操作系统下且需要 makefiles 需要加上该语句。运行中可能会受网络影响导致下载失败多试几次即可。如果一切正常应该可以在根目录下看到 bin 文件夹且里面有一个可执行文件，如果可执行文件可正常运行就大功告成了。\n# 尾 如果您嫌麻烦可以直接从github 下载我项目 https://github.com/IyuMashiro/raylib_raygui_rres_template\n","date":"2025-02-04T00:00:00Z","image":"https://iyumashiro.github.io/img/kano.png","permalink":"https://iyumashiro.github.io/p/cmake/","title":"使用 cmake 构造 raylib"},{"content":"test ","date":"2024-04-08T00:00:00Z","image":"https://iyumashiro.github.io/img/miku.jpg","permalink":"https://iyumashiro.github.io/p/test-chinese/","title":"Chinese Test"}]